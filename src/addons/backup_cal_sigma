subroutine cal_sigma(iq,gf0_tau,pol,sigc)
use modmain
use mod_linresp
use mod_addons_q
use mod_nrkp
use mod_expigqr
implicit none
!
integer,intent(in) :: iq
complex(8),intent(in) :: gf0_tau(lr_nw,nstsv,nkptnrloc)
complex(8),intent(in) :: pol(ngq(iq),ngq(iq),lr_nw)
complex(8),intent(inout) :: sigc(nbnd,nspinor,nkptnrloc,lr_nw)
!
integer :: ig1,ig2,iw,i,ikloc,ist1,ist2,ik,j,n
complex(8),allocatable :: gf0kq_tau(:,:,:)
complex(8),allocatable :: svq(:,:,:)
!test
complex(8),allocatable :: svq_w(:,:,:),pol_w(:,:,:),krnl(:,:,:)
complex(8),allocatable :: mtmp(:,:),mtmp2(:,:),gf0_w(:,:,:),gf0(:,:,:)
integer :: info
integer,allocatable :: ipiv(:)
complex(8) :: wn,tmp1,nb
!
complex(8),allocatable :: ame(:,:)
complex(8) :: zt1,zt2
complex(8),allocatable :: gf0kqtmp(:,:)
character*100 :: fname
!
allocate(gf0kq_tau(lr_nw,nstsv,nkptnrloc))
allocate(ame(ngq(iq),nstsv*nstsv))
allocate(gf0kqtmp(nstsv,lr_nw))
allocate(svq(ngq(iq),ngq(iq),lr_nw))
!test
allocate(svq_w(ngq(iq),ngq(iq),lr_nw))
allocate(pol_w(ngq(iq),ngq(iq),lr_nw))
allocate(krnl(ngq(iq),ngq(iq),2))
allocate(mtmp(ngq(iq),ngq(iq)))
allocate(mtmp2(ngq(iq),ngq(iq)))
allocate(ipiv(ngq(iq)))
allocate(gf0(nstsv,nkptnrloc,lr_nw))
allocate(gf0_w(nstsv,nkptnrloc,lr_nw))
gf0kq_tau=zzero
gf0kqtmp=zzero
svq=zzero
!test
krnl=zzero
mtmp=zzero
mtmp2=zzero
ipiv=0
gf0_w=zzero
gf0=zzero

! restore q->0 matrix elements
if (vq_gamma(iq)) then
  do ikloc=1,nkptnrloc
    ik=mpi_grid_map(nkptnr,dim_k,loc=ikloc)
    do ig1=1,ngq(iq)
      if (igqig(ig1,iq).eq.1) then
        amegqblh(:,ig1,ikloc)=zzero
        do i=1,nmegqblh(ikloc)
          ist1=bmegqblh(1,i,ikloc)
          ist2=bmegqblh(2,i,ikloc)
          if (ist1.eq.ist2) then
            amegqblh(i,ig1,ikloc)=zone
          endif
        enddo
      endif
    enddo
  enddo
endif

! get G(k-q) from other processors
call get_gf0kq(3,gf0_tau,gf0kq_tau)

do iw=1,lr_nw
 do ikloc=1,nkptnrloc
  gf0(:,ikloc,iw)=gf0_tau(iw,:,ikloc)
 enddo
enddo

!test  G(tau) for boson
if ((iq.eq.1).and.mpi_grid_root()) then
 fname="gf0_tau1"
 open(166,file=trim(adjustl(fname)),form="FORMATTED",status="REPLACE")
 do iw=1,lr_nw
   nb=zone/(exp(evalsvnr(4,1)*bhbar)-zone)
   gf0(4,1,iw)=-(zone+nb)*exp(-evalsvnr(4,1)*lr_w(iw))
   write(166,'(3(G16.6))') iw,dreal(gf0(4,1,iw)),dimag(gf0(4,1,iw))
 enddo
 close(166)

 write(*,*) "evalsvnr(4,1):",evalsvnr(4,1)

endif !iq


!G(iw) boson
call ft_tw3(1,1,nstsv,nkptnrloc,lr_nw,gf0,gf0_w)

if ((iq.eq.1).and.mpi_grid_root()) then
 fname="gf0_iwn1"
 open(166,file=trim(adjustl(fname)),form="FORMATTED",status="REPLACE")
 do iw=1,lr_nw
   write(166,'(3(G16.6))') iw,dreal(gf0_w(4,1,iw)),dimag(gf0_w(4,1,iw))
 enddo
 close(166)

 fname="gf0_iwn1_true"
 open(166,file=trim(adjustl(fname)),form="FORMATTED",status="REPLACE")
 n=0
 do iw=-int((lr_nw-1)/2),int(lr_nw/2)
   n=n+1
!   wn=zi*(2.d0*iw+1)*pi/bhbar
   wn=zi*(2.d0*iw)*pi/bhbar
   tmp1=zone/(wn-evalsvnr(4,1))
   write(166,'(3(G16.6))') n,dreal(tmp1),dimag(tmp1)
 enddo
 close(166)

endif !iq

!solve W(tau)
!#ifdef _MPI_
 call psolve_wtau(iq,lr_nw,pol,svq)
!#else

!#endif

if ((iq.eq.1).and.mpi_grid_root()) then
 fname="svq_tau1"
 open(166,file=trim(adjustl(fname)),form="FORMATTED",status="REPLACE")
 do iw=1,lr_nw
   write(166,'(3(G16.6))') dreal(lr_w(iw)),dreal(svq(1,1,iw)),dimag(svq(1,1,iw))
 enddo
 close(166)
endif !iq

!W(iw)
call ft_tw3(1,1,ngq(iq),ngq(iq),lr_nw,svq,svq_w)

!print W(iw)
if ((iq.eq.1).and.mpi_grid_root()) then
 fname="svq_iwn1"
 open(166,file=trim(adjustl(fname)),form="FORMATTED",status="REPLACE")
 do iw=1,lr_nw
   write(166,'(3(G16.6))') iw,dreal(svq_w(1,1,iw)),dimag(svq_w(1,1,iw))
 enddo
 close(166)
endif !iq


!begin test

svq_w=zzero
pol_w=zzero
! get P(iw)
call ft_tw3(1,1,ngq(iq),ngq(iq),lr_nw,pol,pol_w)

!print pol(iw)
if ((iq.eq.1).and.mpi_grid_root()) then
 fname="pol_iwn1"
 open(166,file=trim(adjustl(fname)),form="FORMATTED",status="REPLACE")
 do iw=1,lr_nw
   write(166,'(3(G16.6))') iw,dreal(pol_w(1,1,iw)),dimag(pol_w(1,1,iw))
 enddo
 close(166)
endif !iq

do ig1=1,ngq(iq)
  krnl(ig1,ig1,1)=dcmplx(vhgq(ig1,iq))
! different weight at Gamma
  krnl(ig1,ig1,2)=dcmplx(wtvhgq(ig1,iq))
!  if (mpi_grid_root()) write(*,*) "ig1,vhgq,wtvhgq:",ig1,vhgq(ig1,iq),wtvhgq(ig1,iq)
enddo

do iw=1,lr_nw
! -vP(iw)
 call zgemm('N','N',ngq(iq),ngq(iq),ngq(iq),-zone,krnl(1,1,1),&
        & ngq(iq),pol_w(1,1,iw),ngq(iq),zzero,mtmp(1,1),ngq(iq))

! vP(iw)v
 call zgemm('N','N',ngq(iq),ngq(iq),ngq(iq),-zone,mtmp(1,1),&
        & ngq(iq),krnl(1,1,2),ngq(iq),zzero,svq_w(1,1,iw),ngq(iq)) 

 do ig1=1,ngq(iq)
  mtmp(ig1,ig1)=mtmp(ig1,ig1)+zone
 enddo

 call zgesv(ngq(iq),ngq(iq),mtmp(1,1),ngq(iq),ipiv,svq_w(1,1,iw),&
       & ngq(iq),info)
 if (info.ne.0) write(*,*) "info ne. 0:",info

enddo !iw

if ((iq.eq.1).and.mpi_grid_root()) then
 fname="svq_iwn2"
 open(166,file=trim(adjustl(fname)),form="FORMATTED",status="REPLACE")
 do iw=1,lr_nw
   write(166,'(3(G16.6))') iw,dreal(svq_w(1,1,iw)),dimag(svq_w(1,1,iw))
 enddo
 close(166)
endif !iq

! end test

if (mpi_grid_root()) then
 call timestamp(151)
 write(151,*) "before calculating self-energy!"
 call flushifc(151)
endif

!calculate the self-energy
do ikloc=1,nkptnrloc
 !change order of indices
 do iw=1,lr_nw
  gf0kqtmp(:,iw)=gf0kq_tau(iw,:,ikloc)
 enddo
 !note that amegqblh M(k-q), without flipping jj'
 do ig1=1,ngq(iq)
   ame(ig1,:)=amegqblh(:,ig1,ikloc)
 enddo

 do iw=1,lr_nw
  do i=1,namegqblh(ikloc)
   n=bamegqblh(2,i,ikloc)
   if ((n.gt.qpnb(2)).or.(n.lt.qpnb(1))) cycle  !nk
    
   j=bamegqblh(1,i,ikloc)

   zt2=zzero
   do ig2=1,ngq(iq)
    zt1=zzero
    do ig1=1,ngq(iq)   
      zt1=zt1+dconjg(ame(ig1,i))*svq(ig1,ig2,iw)
    enddo
    zt2=zt2+zt1*ame(ig2,i)
   enddo
  
   sigc(n-qpnb(1)+1,1,ikloc,iw)=sigc(n-qpnb(1)+1,1,ikloc,iw)+&
                          & gf0kqtmp(j,iw)*zt2
  enddo !i
 enddo !iw

enddo !ikloc

if (mpi_grid_root()) then 
 call timestamp(151)
 write(151,*) "after calculating self-energy!"
 call flushifc(151)
endif 

deallocate(ame,gf0kqtmp)
deallocate(gf0kq_tau,svq)
deallocate(svq_w,pol_w,krnl,mtmp,mtmp2,ipiv,gf0,gf0_w)
return
end subroutine
