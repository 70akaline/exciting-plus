subroutine genvclnk(nst,bndrg,delf,vclnk)
use modmain
use mod_nrkp
use mod_addons_q
use mod_linresp,  only : qpnb
implicit none
!
integer, intent(in) :: nst
integer, intent(in) :: bndrg(2,nspinor)
real(8), intent(in) :: delf(nstsv,nkptnr)
real(8), intent(out) :: vclnk(nst,nspinor,nkptnrloc)
!
!local variables
integer jst,ik,ikloc,ias,is,ic,l1,l2,l3,io1,io2,ispn,lm1,lm2,lm3,ig,ir
integer m1, m2, m3
integer ibnd, fbnd, isp1, lmax, indx
complex(8) zt,zt2,zt1(nrmtmax), zrho0
real(8) :: zn(nspecies), cfq, t1
real(8), allocatable :: jlgqr(:,:,:)
real(8), allocatable :: gqc(:), rrmt(:,:)
real(8), allocatable :: tpgqc(:,:)
real(8), external :: gaunt
!
complex(8), allocatable :: zrhomt(:,:,:)
complex(8), allocatable :: zrhoir(:)
complex(8), allocatable :: zrhonkmt(:,:,:,:,:,:)
complex(8), allocatable :: zrhonkir(:,:,:,:)
complex(8), allocatable :: zvclmt(:,:,:)
complex(8), allocatable :: zvclir(:)
complex(8), allocatable :: gntmp(:,:)
complex(8), allocatable :: zfft(:)
complex(8), allocatable :: zvclnk(:,:,:)
complex(8),external :: zfinp2
integer :: inbndrg(nstsv)
!
! calculate the Hartree potential due to change in \rho
! Iek-Heng Chu, 2014
!
allocate(jlgqr(0:lmaxvr+npsden+1,ngvec,nspecies))
allocate(gqc(ngvec))
allocate(rrmt(nrmtmax,nspecies))
allocate(tpgqc(2,ngvec))
!
allocate(gntmp(lmmaxapw,lmmaxapw))
allocate(zfft(ngrtot))
allocate(zrhomt(lmmaxvr,nrmtmax,natmtot))
allocate(zrhonkmt(lmmaxvr,nrmtmax,natmtot,nst,nspinor,nkptnrloc))
allocate(zvclmt(lmmaxvr,nrmtmax,natmtot))
allocate(zrhonkir(ngrtot,nst,nspinor,nkptnrloc))
allocate(zrhoir(ngrtot))
allocate(zvclir(ngrtot))
if (allocated(ylmgq)) deallocate(ylmgq)
allocate(ylmgq(lmmaxvr,ngvec))
if (allocated(sfacgq)) deallocate(sfacgq)
allocate(sfacgq(ngvec,natmtot))
allocate(zvclnk(nst,nspinor,nkptnrloc))
!
!
vclnk=0.d0
zvclnk=zzero
zrhomt=zzero
zrhoir=zzero
zrhonkmt=zzero
zrhonkir=zzero
zvclmt=zzero
zvclir=zzero
zfft=zzero
inbndrg(:)=0
lmax=lmaxvr+npsden+1
rrmt=0.d0
! coefficient for long-range term
cfq=0.5d0*(omega/pi)**2
! set the nuclear charges to zero
zn(:)=0.d0

do is=1,nspecies
 do ir=1,nrmt(is)
   rrmt(ir,is)=spr(ir,is)
 enddo
enddo

do ig=1,ngvec
! G+q-vector length and (theta, phi) coordinates
  call sphcrd(vgc(:,ig),gqc(ig),tpgqc(:,ig))
! spherical harmonics for G+q-vectors
  call genylm(lmaxvr,tpgqc(:,ig),ylmgq(:,ig))
end do

! structure factor
call gensfacgp(ngvec,vgc,ngvec,sfacgq)
! compute the required spherical Bessel functions
call genjlgpr(lmax,gqc,jlgqr)

! check if band index falls in bndrg
do jst=1,nstsv
 do isp1=1,nspinor
  if (jst.ge.bndrg(1,isp1).and.jst.le.bndrg(2,isp1)) then
   inbndrg(jst)=isp1
   exit
  endif
 enddo
enddo

if (mpi_grid_root()) then
 do jst=1,nstsv
  write(*,*) "jst,inbndrg:",jst,inbndrg(jst)
 enddo
endif

! construct the new charge density
do ikloc=1,nkptnrloc
 ik=mpi_grid_map(nkptnr,dim_k,loc=ikloc)

 do jst=1,nstsv
   if (delf(jst,ik).ge.1d-2.or.inbndrg(jst).gt.0) then
    if (inbndrg(jst).gt.0) indx=jst-bndrg(1,inbndrg(jst))+1
    do lm3=1,lmmaxvr
      l3=lm2l(lm3)
      m3=lm2m(lm3)
      do ias=1,natmtot
        is=ias2is(ias)
        ic=ias2ic(ias)
        zt1=zzero
        do l1=0,lmaxapw; do io1=1,nufr(l1,is)
          do l2=0,lmaxapw; do io2=1,nufr(l2,is)
            if (mod(l1+l2+l3,2).eq.0) then
              zt=zzero
              do ispn=1,nspinor
                do m2= -l2, l2
                  lm2=idxlm(l2,m2)
                  do m1= -l1, l1
                    lm1=idxlm(l1, m1)
                    zt=zt+dconjg(wfsvmtnrloc(lm1,io1,ias,ispn,jst,ikloc))*&
                      &wfsvmtnrloc(lm2,io2,ias,ispn,jst,ikloc)*gaunt(l2,l3,l1,m2,m3,m1)
                  enddo !m1
                enddo !m2
              enddo !ispn
              zt1(:)=zt1(:)+zt*ufr(:,l1,io1,ic)*ufr(:,l2,io2,ic)
            endif
          enddo; enddo !l2, io2
        enddo; enddo !l1, io1
        ! store the orbital square if in bndrg
        if (inbndrg(jst).gt.0) then
         zrhonkmt(lm3,:,ias,indx,inbndrg(jst),ikloc)=zt1(:)
        endif
        if (delf(jst,ik).ge.1.d-2) &
            & zrhomt(lm3,:,ias)=zrhomt(lm3,:,ias)+zt1(:)*delf(jst,ik)/occmax
      enddo !ias
    enddo !lm3

    do ispn=1,nspinor
      zfft=zzero
      do ig=1,ngknr(ikloc)
        zfft(igfft(igkignr(ig,ikloc)))=wfsvitnrloc(ig,ispn,jst,ikloc)
      enddo
      call zfftifc(3,ngrid,1,zfft)
      do ir=1,ngrtot
        zt=dconjg(zfft(ir))*zfft(ir)/omega
        if (inbndrg(jst).gt.0) zrhonkir(ir,indx,inbndrg(jst),ikloc)=&
              & zrhonkir(ir,indx,inbndrg(jst),ikloc)+zt
        if (delf(jst,ik).ge.1.d-2) &
              & zrhoir(ir)=zrhoir(ir)+zt*delf(jst,ik)/occmax
      enddo
    enddo !ispn

   endif
 enddo !jst
enddo !ikloc

call mpi_grid_reduce(zrhomt(1,1,1),lmmaxvr*nrmtmax*natmtot,dims=(/dim_k/),all=.true.)
call mpi_grid_reduce(zrhoir(1),ngrtot,dims=(/dim_k/),all=.true.)

zrhomt(:,:,:)=zrhomt(:,:,:)/nkptnr
zrhoir(:)=zrhoir(:)/nkptnr

! solve for Coulomb Potential for the new charge density
!call zpotcoul(nrmt,nrmtmax,nrmtmax,rrmt,1,gqc,jlgqr,ylmgq,sfacgq,zn,&
!     &zrhomt,zrhoir,zvclmt,zvclir,zrho0)

!test
call zpotcoul(nrmt,nrmtmax,nrmtmax,rrmt,1,gqc,jlgqr,ylmgq,sfacgq,zn,&
     &dcmplx(rhomt),dcmplx(rhoir),zvclmt,zvclir,zrho0)

!t1=cfq*wiq2(1)*(dble(zrho0)**2+dimag(zrho0)**2)

do ikloc=1,nkptnrloc
 do isp1=1,nspinor
   do jst=1,nst
    zvclnk(jst,isp1,ikloc)=zfinp2(.true.,zrhonkmt(:,:,:,jst,isp1,ikloc),zvclmt,&
                          &zrhonkir(:,jst,isp1,ikloc),zvclir,nrmt,rrmt)

    zt2=zfinp2(.true.,zrhonkmt(:,:,:,jst,isp1,ikloc),dcmplx(vclmt),&
                          &zrhonkir(:,jst,isp1,ikloc),dcmplx(vclir),nrmt,rrmt)
    if (mpi_grid_root()) then
     write(*,*) "jst,isp1,ikloc:",jst,isp1,ikloc
     write(*,*) "vclnk,zt2:",dreal(zvclnk(jst,isp1,ikloc)),dreal(zt2)
    endif
   enddo !jst
 enddo !isp1
enddo !ikloc

! convert to real array
vclnk(:,:,:)=dreal(zvclnk(:,:,:))

deallocate(gntmp,zfft,zrhomt,zrhoir,zvclmt,zvclir,zrhonkmt,zrhonkir)
deallocate(gqc,jlgqr,rrmt,ylmgq,sfacgq,tpgqc,zvclnk)
return
end subroutine
